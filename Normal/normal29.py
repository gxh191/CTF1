# -*- coding: UTF-8 -*-
from unicorn import *
from unicorn import arm_const as ac
import time

def Unicorn(input):
    bytescode = b'\x08\xb0-\xe5\x04\xe0\x8d\xe5\x04\xb0\x8d\xe2\x10\xd0M\xe2\x10\x00\x0b\xe5\x14\x10\x0b\xe5\x000\xa0\xe3\x080\x0b\xe5\x000\xa0\xe3\x080\x0b\xe5\x1b\x00\x00\xea\x080\x1b\xe5\x010\x03\xe2\x00\x00S\xe3\n\x00\x00\n\x080\x1b\xe5\x10 \x1b\xe5\x030\x82\xe0\x08 \x1b\xe5\x10\x10\x1b\xe5\x02 \x81\xe0\x00 \xd2\xe5\x07 \x82\xe2r \xef\xe6\x00 \xc3\xe5\t\x00\x00\xea\x080\x1b\xe5\x10 \x1b\xe5\x030\x82\xe0\x08 \x1b\xe5\x10\x10\x1b\xe5\x02 \x81\xe0\x00 \xd2\xe5\x04 \x82\xe2r \xef\xe6\x00 \xc3\xe5\x080\x1b\xe5\x010\x83\xe2\x080\x0b\xe5\x080\x1b\xe5\x1e\x00S\xe3\xe0\xff\xff\xda\x000\xa0\xe3\x080\x0b\xe5\x17\x00\x00\xea\x080\x1b\xe5\x10 \x1b\xe5\x030\x82\xe0\x000\xd3\xe5\x0c0\x0b\xe5\x080\x1b\xe5\x10 \x1b\xe5\x030\x82\xe0\x08 \x1b\xe5\x10 \x82\xe2\x10\x10\x1b\xe5\x02 \x81\xe0\x00 \xd2\xe5\x00 \xc3\xe5\x080\x1b\xe5\x100\x83\xe2\x10 \x1b\xe5\x030\x82\xe0\x0c \x1b\xe5r \xef\xe6\x00 \xc3\xe5\x080\x1b\xe5\x010\x83\xe2\x080\x0b\xe5\x080\x1b\xe5\x0e\x00S\xe3\xe4\xff\xff\xda\x000\xa0\xe3\x080\x0b\xe5\x17\x00\x00\xea\x080\x1b\xe5\x10 \x1b\xe5\x030\x82\xe0\x000\xd3\xe5\x0c0\x0b\xe5\x080\x1b\xe5\x10 \x1b\xe5\x030\x82\xe0\x08 \x1b\xe5\x01 \x82\xe2\x10\x10\x1b\xe5\x02 \x81\xe0\x00 \xd2\xe5\x00 \xc3\xe5\x080\x1b\xe5\x010\x83\xe2\x10 \x1b\xe5\x030\x82\xe0\x0c \x1b\xe5r \xef\xe6\x00 \xc3\xe5\x080\x1b\xe5\x020\x83\xe2\x080\x0b\xe5\x080\x1b\xe5\x1d\x00S\xe3\xe4\xff\xff\xda\x140\x1b\xe5\x00\x00S\xe3\x01\x00\x00\x1a\x010\xa0\xe3\x04\x00\x00\xea\x140\x1b\xe5\x010C\xe2\x03\x10\xa0\xe1\x10\x00\x1b\xe5\x8f\xff\xff\xeb\x03\x00\xa0\xe1\x04\xd0K\xe2\x00\xb0\x9d\xe5\x04\xd0\x8d\xe2\x04\xf0\x9d\xe4'
    cmp_data = [149, 187, 165, 189, 151, 176, 171, 165, 114, 180, 176, 161, 115, 181, 155, 174, 117, 163, 174, 115, 187, 161, 163, 175, 163, 116, 115, 176, 169, 99, 185]

    def hook_code(mu, address, size, user_data):
        if address == BASE + 420:#0x1A4
            data = mu.mem_read(0, 31)# 读取加密函数加密后的数据
            if [ data[i] for i in range(len(data)) ] == cmp_data:
                print 'success'
                time.sleep(5)
                exit(0)
            else:
                print 'fail'
                time.sleep(5)
                exit(0)
    # 初始化 Unicorn
    mu = Uc(UC_ARCH_ARM, UC_MODE_ARM)
    BASE = 4194304# 4m
    STACK_ADDR1 = 0
    STACK_ADDR2 = 1024
    STACK_SIZE = 1048576# 1m
    # 映射 1M 的模拟执行内存空间 ， 所有进程中的CPU操作都应该只访问该内存区域， 映射的内存具有默认的读, 写和执行权限.
    mu.mem_map(BASE, 1048576)
    # 模拟指定大小的栈空间
    mu.mem_map(STACK_ADDR1, STACK_SIZE)
    # 向栈空间的 0 地址写入 input.encode()
    mu.mem_write(STACK_ADDR1, input.encode())
    # 设置寄存器 R0 的值为 0 参数1 也就是输入
    mu.reg_write(ac.UC_ARM_REG_R0, 0)
    # 设置寄存器 R1 的值为 11 参数2 11
    mu.reg_write(ac.UC_ARM_REG_R1, 11)
    # 设置寄存器 SP 的值为 1023
    mu.reg_write(ac.UC_ARM_REG_SP, STACK_ADDR2 - 1)# 1023
    # 向内存地址 4194304 写入代码 bytescode
    mu.mem_write(BASE, bytescode)
    # 添加一个钩子，在模拟每一个指令前调用 hook_code
    mu.hook_add(UC_HOOK_CODE, hook_code)
    # 开始模拟执行，开始地址 4194304 ，结束地址 4194304 + 424
    mu.emu_start(BASE, BASE + 424)
if __name__ == '__main__':
    input = raw_input('plz input your flag:')
    Unicorn(input)
